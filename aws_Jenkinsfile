pipeline {
    agent any
   
    environment {
        GOOGLE_CHAT_WEBHOOK = "https://chat.googleapis.com/v1/spaces/AAAAmNzVX-0/messages?key=AIzaSyDdI0hCZtE6vySjMm-WEfRq3CPzqKqqsHI&token=-ehw-co0VWGnsDY5SLqofPk6gX0TNB5vSvD_O0zO4Eo"
        AWS_Account_Id = "392698013629"
        AWS_Region = "us-east-1"
        Git_Credentials = 'github-admin-pat'
		Code_Repo = 'https://github.com/Simpleenergy-Pvt-Ltd/se-flink-canparser-job.git'
		// Helm_Repo = 'https://github.com/Simpleenergy-Pvt-Ltd/se-eks-manifest.git'
		// Helm_Branch = 'main'
		Microservice_Name = 'flink-job'
		// Helm_Directory_Name = 'website-blog'
		Namespace = 'flink-stage'
        // ENV_FILE = '/var/lib/jenkins/workspace/flink-job/.env'
	EKS_Cluster_Name = 'simpleenergy-dev-eks-cluster'
    }
    
    stages {

        stage('versioning') {
            steps {
                script {
                    if(env.GIT_BRANCH == 'origin/release/stage'){
                        def latestCommit = sh(script: "git rev-list --no-merges -n 1 HEAD", returnStdout: true).trim()
                        def latestTagInfo = sh(script: "git describe --tags --abbrev=0 ${latestCommit}", returnStdout: true).trim()
                        def latestTagCommit = sh(script: "git rev-list -n 1 ${latestTagInfo}", returnStdout: true).trim()
                        if (latestTagCommit != latestCommit) {
                            error "The latest tag (${latestTagInfo}) is associated with a previous commit (${latestTagCommit}). Please create a new tag for the current commit."
                        } else {
                            echo "Latest tag: ${latestTagInfo}"
                        }

                        env.GIT_TAG = latestTagInfo
                        echo "Tagged - $latestTagInfo"
                    }
                    else if (env.GIT_BRANCH == 'origin/release/prod'){
                        echo "Release tag: ${env.RELEASE_TAG}"
                    }
                }
            }
            post {
                failure {
                    script {
                        sendGoogleChatNotification("Build Number: ${currentBuild.fullDisplayName} - versioning Failed ðŸ˜¬")
                    }
                }
            }
            
        }
        
        stage('Environment') {
            steps {
                script {
                    if(env.GIT_BRANCH == '*/master'){
                        // no dev
                    }
                    else if(env.GIT_BRANCH == 'origin/release/stage'){
                        env.BRANCH = "release/stage"
                        env.DOCKER_IMAGE_REPOSITORY_NAME="se-flink-job-stage-eks"
                        env.AWS_Region ="us-east-1"
                        // env.secretId= "website/blog-fe"
                        env.IMAGE_TAG= GIT_TAG
                        env.KUBERNETES_REPOSITORY_BRANCH = "release/stage"
                    }
                    else if(env.GIT_BRANCH == 'origin/release/prod'){
                        env.BRANCH = "release/prod"
                        env.DOCKER_IMAGE_REPOSITORY_NAME=""
                        env.AWS_Region =""
                        env.secretId= ""
                        env.IMAGE_TAG= env.RELEASE_TAG
                        env.KUBERNETES_REPOSITORY_BRANCH = "release/prod"
                    }
                }
            }
            post {
                failure {
                    script {
                        sendGoogleChatNotification("Build Number: ${currentBuild.fullDisplayName} - Environment variables initilization Failed ðŸ˜¬")
                    }
                }
            }
            
        }
        
        
        stage('Git Checkout') {
            steps {
                script{
                
                git branch: "${BRANCH}", credentialsId: "${env.Git_Credentials}", url: "${env.Code_Repo}"   
            
                }
            }
            post {
                failure {
                    script {
                        sendGoogleChatNotification("Build Number: ${currentBuild.fullDisplayName} - SCM failed ðŸ˜¬")
                    }
                }
            }
            
        }
        
        // stage('Fetch Secrets') {
        //     steps {
        //         script {
                    
        //             // Determine the secret ID based on the branch
        //             if (env.GIT_BRANCH == 'origin/release/stage') {
        //                 echo "Fetching secrets for stage environment..."
        //                 secretId = "website/blog-fe"
        //             } else if (env.GIT_BRANCH == 'origin/release/prod') {
        //                 echo "Fetching secrets for prod environment..."
        //                 secretId = '' // Add the correct secret ID for production here
        //             } else {
        //                 error "Unsupported branch: ${env.GIT_BRANCH}. Only 'release/stage' and 'release/prod' are allowed."
        //             }
        //             // yet to configure stage for this.
        //             try {
        //                 echo "Fetching secrets from AWS Secrets Manager..."
                        
        //                 // Fetch secrets from AWS Secrets Manager
        //                 def secretsJson = sh(
        //                     script: """
        //                         aws secretsmanager get-secret-value --secret-id "${secretId}" --region "${AWS_Region}" --query SecretString --output text
        //                     """,
        //                     returnStdout: true
        //                 ).trim()
                        
        //                 if (!secretsJson) {
        //                     error "Failed to fetch secrets for secret ID: ${secretId}"
        //                 }
        
        //                 // Remove existing .env file if it exists
        //                 if (fileExists(ENV_FILE)) {
        //                     echo "Removing existing .env file..."
        //                     sh "rm -f ${ENV_FILE}"
        //                 }
        
        //                 // Write secrets.json to file
        //                 writeFile file: 'secrets.json', text: secretsJson
        
        //                 // Parse JSON and convert to key="value" format
        //                 def secrets = readJSON file: 'secrets.json'
        //                 def envFileContent = secrets.collect { key, value ->
        //                     "${key}=\"${value}\""
        //                 }.join('\n')
        
        //                 // Write to .env file
        //                 writeFile file: ENV_FILE, text: envFileContent
        
        //                 // Clean up temporary secrets.json
        //                 sh "rm -f secrets.json"
        
        //                 echo "Secrets fetched and added to ${ENV_FILE} successfully."
        //             } catch (Exception e) {
        //                 echo "An error occurred while fetching secrets: ${e.getMessage()}"
        //                 error "Failed to fetch and process secrets."
        //             }
        //         }
        //     }
        //     post {
        //         failure {
        //             script {
        //                 sendGoogleChatNotification("Build Number: ${currentBuild.fullDisplayName} - env fetch Failed ðŸ˜¬")
        //             }
        //         }
        //     }
        // }
        
        stage('build') {
            steps {
                    script {
                    def latestCommit = sh(script: "git rev-list --no-merges -n 1 HEAD", returnStdout: true).trim()
                    def latestTagInfo = sh(script: "git describe --tags --abbrev=0 ${latestCommit}", returnStdout: true).trim()
                    def latestTagCommit = sh(script: "git rev-list -n 1 ${latestTagInfo}", returnStdout: true).trim()

                    env.GIT_TAG = latestTagInfo  // Set GIT_TAG
                    env.IMAGE_TAG = env.GIT_TAG  // Assign IMAGE_TAG using GIT_TAG

                    echo "Tagged - $latestTagInfo"
                    
                    env.DOCKER_IMAGE_REPOSITORY_NAME="se-flink-job-stage-eks"
                    
                    
                    sh " docker build -t ${env.DOCKER_IMAGE_REPOSITORY_NAME}:${env.IMAGE_TAG} . "
                    }
                }
            post {
                failure {
                    script {
                        sendGoogleChatNotification("Build Number: ${currentBuild.fullDisplayName} - docker build Failed ðŸ˜¬")
                    }
                }
            }
        }
        
        stage('push') {
            steps {
                script {
                    if (env.GIT_BRANCH == 'origin/release/stage') {
                        sh """
                            docker tag ${env.DOCKER_IMAGE_REPOSITORY_NAME}:${env.IMAGE_TAG} ${env.AWS_Account_Id}.dkr.ecr.${env.AWS_Region}.amazonaws.com/${env.DOCKER_IMAGE_REPOSITORY_NAME}:${env.IMAGE_TAG}
                            echo "Pushing image To ECR ..."
                            aws ecr get-login-password --region ${env.AWS_Region} | docker login --username AWS --password-stdin ${env.AWS_Account_Id}.dkr.ecr.${env.AWS_Region}.amazonaws.com
                            docker push ${env.AWS_Account_Id}.dkr.ecr.${env.AWS_Region}.amazonaws.com/${env.DOCKER_IMAGE_REPOSITORY_NAME}:${env.IMAGE_TAG}
                            echo "Docker image pushed successfully."
                            echo "Removing the Docker image running on Jenkins server..."
                            docker rmi ${env.DOCKER_IMAGE_REPOSITORY_NAME}:${env.IMAGE_TAG} --force
                            docker rmi ${env.AWS_Account_Id}.dkr.ecr.${env.AWS_Region}.amazonaws.com/${env.DOCKER_IMAGE_REPOSITORY_NAME}:${env.IMAGE_TAG} --force
                        """
                    } else if (env.GIT_BRANCH == 'origin/release/prod') {
                        sh """
                            docker tag ${env.AWS_ECR_Repo}:${env.IMAGE_TAG} ${env.AWS_Account_Id}.dkr.ecr.${env.AWS_Region}.amazonaws.com/${env.AWS_ECR_Repo}:${env.IMAGE_TAG}
                            echo "Pushing image To ECR ..."
                            aws ecr get-login-password --region ${env.AWS_Region} | docker login --username AWS --password-stdin ${env.AWS_Account_Id}.dkr.ecr.${env.AWS_Region}.amazonaws.com
                            docker push ${env.AWS_Account_Id}.dkr.ecr.${env.AWS_Region}.amazonaws.com/${env.AWS_ECR_Repo}:${env.IMAGE_TAG}
                            echo "Docker image pushed successfully."
                            echo "Removing the Docker image running on Jenkins server..."
                            docker rmi ${env.AWS_ECR_Repo}:${env.IMAGE_TAG} --force
                            docker rmi ${env.AWS_Account_Id}.dkr.ecr.${env.AWS_Region}.amazonaws.com/${env.AWS_ECR_Repo}:${env.IMAGE_TAG} --force
                        """
                    }
                }
            }
            post {
                failure {
                    script {
                        sendGoogleChatNotification("Build Number: ${currentBuild.fullDisplayName} - docker image push failed ðŸ˜¬")
                    }
                }
            }
        }

        
        // stage('Clone Helm Charts') {
        //     steps {
        //       script{
        //          dir('helm-charts'){
        //          git branch: "${env.Helm_Branch}", credentialsId: "${env.Git_Credentials}", url: "${env.Helm_Repo}"
        //          }
        //         } 
        //     }
        //     post {
        //         failure {
        //             script {
        //                 sendGoogleChatNotification("Build Number: ${currentBuild.fullDisplayName} - Clone Helm Charts failed ðŸ˜¬")
        //             }
        //         }
        //     }
        // }
        
        // stage('Update tag in Helm Charts') {
        // steps {
        //     script {
        //         dir('helm-charts') {
        //             // Define the values file based on the environment
        //             def valuesFilePath = "${env.Helm_Directory_Name}/values.yaml" 
    
        //                 // Update the tag in the appropriate values file
        //                 sh """
        //                     sed -i "s|tag:.*|tag: ${env.IMAGE_TAG}|" ${valuesFilePath}
        //                 """
    
        //                 // Commit and push the changes
        //                 withCredentials([usernamePassword(credentialsId: "${env.Git_Credentials}", usernameVariable: 'GIT_USERNAME', passwordVariable: 'GIT_PASSWORD')]) {
        //                 sh """
        //                     git config user.name "${env.GIT_USERNAME}"
        //                     git config user.email "jenkins@rapyder.com"
                    
        //                     # Check if there are changes in the file
        //                     if git diff --quiet ${valuesFilePath}; then
        //                         echo "No changes detected in ${valuesFilePath}. Skipping commit and push."
        //                     else
        //                         echo "Changes detected in ${valuesFilePath}. Committing and pushing..."
        //                         git add ${valuesFilePath}
        //                         git commit -m "Updated image tag to ${env.DOCKER_IMAGE_REPOSITORY_NAME} in ${valuesFilePath}"
        //                         git push https://${env.GIT_USERNAME}:${env.GIT_PASSWORD}@github.com/Simpleenergy-Pvt-Ltd/se-eks-manifest.git ${env.Helm_Branch}
        //                     fi
        //                 """
        //             }

        //             } 
        //         }
        //     }
        //     post {
        //         failure {
        //             script {
        //                 sendGoogleChatNotification("Build Number: ${currentBuild.fullDisplayName} - Update tag in Helm Charts failed ðŸ˜¬")
        //             }
        //         }
        //     }
        // }

        // stage('Deploy to EKS') {
		// 	steps {
		// 		script {
		// 			echo "Deploying Helm Chart to EKS..."
		// 			sh """
		// 				aws eks update-kubeconfig --region ${env.AWS_Region} --name ${env.EKS_Cluster_Name}
		// 			"""
					
		// 			dir('helm-charts') {
		// 				sh "helm upgrade --install ${env.Microservice_Name} ${env.Helm_Directory_Name} -n ${env.Namespace} --values ${env.Helm_Directory_Name}/values.yaml"
		// 			}
		// 			echo "Helm deployment completed successfully."
		// 		}
		// 	}
        //     post {
        //         failure {
        //             script {
        //                 sendGoogleChatNotification("Build Number: ${currentBuild.fullDisplayName} - Deploy to EKS failed ðŸ˜¬")
        //             }
        //         }
        //     }
		// }
        
        stage('success') {
            steps {
                script {
                    sh 'echo build success'
                }
            }
            post{
                success {
                    script {
                        sendGoogleChatNotification("Build Number: ${currentBuild.fullDisplayName} -  version: ${IMAGE_TAG} Deployment Successful âš¡")
                    }
                }
            }
        }
    }  
}    

def sendGoogleChatNotification(message) {
    def url = env.GOOGLE_CHAT_WEBHOOK
    def payload = [
        text: message
    ]
    def response = httpRequest(
        contentType: 'APPLICATION_JSON',
        httpMode: 'POST',
        requestBody: groovy.json.JsonOutput.toJson(payload),
        url: url
    )
    if (response.status != 200) {
        error "Failed to send message to Google Chat. HTTP status: ${response.status}, Response: ${response.content}"
    }
}
